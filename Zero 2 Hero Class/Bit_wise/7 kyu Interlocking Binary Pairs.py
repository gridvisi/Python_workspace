'''
https://www.codewars.com/kata/628e3ee2e1daf90030239e8a/train/python

for a, b, expected in ( ( 9, 4,  True ),
                        ( 3, 6, False ),
                        ( 2, 5,  True ),
                        ( 7, 1, False ),
                        ( 0, 8,  True )

dyq666
 等 55 人赞同了该文章
什么是位操作
计算机中的数字都是用二进制形式表示的，在python里面，给数字加上前缀 '0b' 表示是二进制数字，如下示例，左边是二进制，右边是

0b1 => 1
0b10 => 2
0b1111 => 15
类似的，python当中的十六进制和八进制数字的前缀分别为 '0x' 和 '0'，下面的例子中右边是十进制

# 十六进制
0x10 => 16
0xff => 255
# 八进制
010 => 8
017 => 15
二进制数字有自己的特殊运算，是对每一位数字分别进行的操作，所以叫做位操作，Python共有以下几种位操作符：

x >> y # 返回 x 向右移 y 位得到的结果
x << y # 返回 x 向左移 y 位得到的结果
x & y # 且操作，返回结果的每一位是 x 和 y 中对应位做 and 运算的结果，只有 1 and 1 = 1，其他情况位0
x | y # 或操作，返回结果的每一位是 x 和 y 中对应位做 or 运算的结果，只有 0 or 0 = 0，其他情况位1
~x # 反转操作，对 x 求的每一位求补，只需记住结果是 -x - 1
x ^ y # 或非运算，如果 y 对应位是0，那么结果位取 x 的对应位，如果 y 对应位是1，取 x 对应位的补
位操作详解
左移和右移操作

顾名思义，左移和右移的意思就是把位数整体向左或者向右移动若干位。比如1111向右移一位就变成了0111，原来没有的位自动填0，超出范围的位舍弃掉。下面再看几个例子：

0b1111 >> 1 = 0b111 = 7
0b1010 << 2 = 0b101000 = 40
0b111111 >> 3 = 0b111 = 7
0b1 << 4 = 0b10000 = 16
向右移1位可以看成除以2，向左移一位可以看成乘以2。移动n位可以看成乘以或者除以2的n次方。

8 >> 2 <=> 8 / 2 / 2 <=> 0b1000 >> 2 = 0b10 = 2
8 << 2 <=> 8 * 2 * 2 <=> 0b1000 << 2 = 0b100000 = 32
且操作 &

对于单个位的且操作

1 & 1 = 1

1 & 0 = 0 & 1 = 0 & 0 = 0

两个数字的且操作就是对每一位进行且操作取结果

0b1 & 0b0 = 0
0b1111 & 0b1010 = 0b1010 = 10
0b1010 & 0b1100 = 0b1000 = 8
或操作 |

对于单个位的或操作

1 | 0 = 0 | 1 = 1 | 1 = 1

0 | 0 = 0

两个数字的或操作就是对每一位进行或操作取结果

0b1 | 0b0 = 0b1 =1
0b1000 | 0b0111 = 0b1111 = 15
0b1010 | 0b1100 = 0b1110 = 14
反转操作 ~

python的反转操作只接受一个参数n，n必须是整数，效果是对n的内部表示的每一位求补，运算结果位 [公式]

~8 = -9
一些同学可能会疑惑，~8不应该是 ~0b1000 = 0b0001 = 1 才对吗。事情是这样的，计算机在内部表示负整数的时候用的是正数的补，比如 0b0001 是1，它的补是 0b1110，这个时候0b1110 在计算机内部不是7，而是-1。 这样一来，可以推导出来~n的结果是 [公式] 。不过你自己写的0b1111在这个语境下并不是一个负数，所以结果仍是15。

或非操作 ^

对于 x ^ y，如果y的位是0，那么取x的原始值，如果y的位是1，那么取x此位的补，例如

0b1111 ^ 0b0101 = 0b1010
0b1111 ^ 0b1 = 0b1110 # 自动填0
发布于 2017-08-09 20:22
'''

print(type(0b1111),0b0101 )
print(bin(3)[2:],2 , bin(6)[2:],2)
def interlockable(a, b):
    #  <----  hajime!
    return False if int(bin(a)[2:],2) ^ int(bin(b)[2:],2) else True

a,b = 9,4
#a,b = 3,6
#a,b = 1,2
print(interlockable(a,b))

#top1
def interlockable(a, b):
    return not a & b