'''
https://www.codewars.com/kata/5a1502db46d84395ab00008a/train/python

A special type of prime is generated by the formula p = 2^m * 3^n + 1 where m and n can be any non-negative integer.

The first 5 of these primes are 2, 3, 5, 7, 13, and are generated as follows:

2 = 2^0 * 3^0 + 1
3 = 2^1 * 3^0 + 1
5 = 2^2 * 3^0 + 1
7 = 2^1 * 3^1 + 1
13 = 2^2 * 3^1 + 1
..and so on
You will be given a range and your task is to return the number of primes that have this
property. For example, solve(0,15) = 5, because there are only 5 such primes >= 0 and < 15;
they are 2,3,5,7,13. The upper limit of the tests will not exceed 1,500,000.

More examples in the test cases.

Test.it("Basic tests")
Test.assert_equals(solve(0,10),4)
Test.assert_equals(solve(0,15),5)
Test.assert_equals(solve(0,100),10)
Test.assert_equals(solve(100,1000),8)

'''
# THE Stone-prime is divide by 2 or 3 continue
# 问题等效于n的所有因子只有2或3
import math
def isPrime(x):
    if x == 0 or x == 1:return False
    if x == 2:return True
    else:
        for i in range(2,int(math.sqrt(x))+1):
            if x % i == 0:return False
        return True
#x = [i for i in range(10)]
#print([(x,isPrime(x)) for x in range(20)])

def iStonePrime(x):  #very slow !!!
    end = x//2
    ans = []
    for i in range(end):
        for j in range(end):
            if isPrime(2**i * 3**j + 1) and 2**i * 3**j + 1 < x:
                ans.append(2**i * 3**j + 1)
    return ans
x = 30
#print(f'{x}:',iStonePrime(x))


def iStonePrime(x):
    if x == 0 or x == 1:return False
    if x == 2:return True
    #xstart = x
    #factor = []
    #ans = ''
    x = x - 1
    for i in range(2,x+1):
        #n = 0
        while x % i == 0:
            x //= i
            #factor.append(i)
            #n += 1

            if i > 3:return False
        if x == 1:
            return True
        #ans += f"{i}^{n} * "
        #if x == 1:
        #    return f"{xstart} = {ans[:-3]} + 1"

#x = 3
print([(x,iStonePrime(x)) for x in range(20)])


def solve(x,y):
    cunt = 0
    for i in range(x,y+1):
        if iStonePrime(i) and isPrime(i):
            cunt += 1
    return cunt
x,y = 0,100
#x,y = 100,1000
print(solve(x,y))


'''

def iStonePrime(x):
    xstart = x
    factor = []
    ans = ''
    x,i = x - 1,2
    for i in range(2,x+1):
        n = 0
        while x % i == 0:
            x //= i
            factor.append(i)
            n += 1

            #ans.append((i,n))
            #if n > 1:
        ans += f"{i}^{n} * "
        if x == 1:
            #return ans[:-3],set(factor).issubset({2,3})  #factor
            return f"{xstart} = {ans[:-3]} + 1"
    #print(x)
    #return set(factor).issubset({2,3})
x = 13
print(iStonePrime(x))
'''

#1st
def isPrime(x):
    if x <= 3: # ignore cases of 0 and 1
        return True
    f = 2
    while f * f <= x:
        if x % f == 0:
            return False
        f += 2 if f != 2 else 1
    return True

def solve(x, y):
    answer = 0
    for m in range(21): # 2^21 > 1.5M
        for n in range(13): # 3^13 > 1.5M
            suspect = 2 ** m * 3 ** n + 1
            if suspect > y:
                continue
            if x <= suspect < y and isPrime(suspect):
                answer += 1
    return answer