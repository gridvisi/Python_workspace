'''
https://www.codewars.com/kata/5f5daf1a209a64001183af9b/train/python

制作巧克力
万圣节快到了，我们必须分发巧克力。我们需要组装一个目标克数的巧克力包裹。可以假设目标总是一个正的整数值。

有小巧克力（每个2克）和大巧克力（每个5克）。
为了达到目标，巧克力（大的和小的）必须按原样使用，也就是说，不能将巧克力打成小块。
最大限度地使用现有的大巧克力，以达到预期的目标。只有这样，你才应该继续使用小巧克力。
注意："最大化 "并不意味着你必须在使用小巧克力之前使用所有可用的大巧克力。
例如，考虑目标是6，大=1，小=3。使用现有的一块大巧克力，不可能达到剩余的1的重量，因此，避免使用大巧克力。使用现有的3块小巧克力，实现目标。
确定为实现所需包裹重量所需的小巧克力的数量。

写一个函数make_chocolates，它将接受三个整数值作为参数，顺序如下。

小 -> 可用的小巧克力的数量
大 -> 可用的大巧克力的数量
目标 -> 最终包裹的理想重量
该函数应该返回实现目标所需的小巧克力的数量。只有在大巧克力和小巧克力的任何可能组合都不能实现目标时，该函数才应返回-1。

例子
make_chocolates (4, 1, 13) => 4
make_chocolates (4, 1, 14) => -1
make_chocolates (2, 1, 7) => 1

# 使用大巧克力可以防止目标
# 成就，因此不要使用它!
make_chocolates (3, 1, 6) => 3
'''
print(list(range(10,-1,-5)))


# return the number of small chocolates required to achieve
# the desired goal. Return -1 if the goal cannot be achieved
def make_chocolates(small, big, goal):
    # s,b = goal//2,big//5
    for i in range(big * 5, -1, -5):
        for j in range(0, small * 2 + 1, 2):
            if i + j == goal:
                return j // 2
    else:
        return -1


#1st
def make_chocolates(s,b,n):
    bigs = min(n//5,b)
    n -= 5 * bigs
    if n&1 and bigs: n+=5
    smalls = min(s,n//2)
    return -1 if n-2*smalls else smalls


print(4&1)
print(bin(4),bin(1))
'''
&	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
|	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
^	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。
<<	左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
>>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数	a >> 2 输出结果 15 ，二进制解释： 0000 1111
'''

'''
今天的任务：
你有一家网上售卖坚果的小店，坚果有两种包装​：
1、小包装的一袋2斤
2、大包装的一袋5斤
现在你要根据订单的需要判断​：库存的两种包装的坚果，能否恰好凑出订单要求购买的重量​。而且，优先考虑用大包装的；
测试用​栗子如下：
​输入：(4, 1, 13) ——>输出： 4*2 + 5*1

#订单是13斤，库存4袋小包装，1袋大包装，所以库存恰好满足，不多不少

​输入：(4, 1, 14) ——> 输出：4*2 +5*1，缺1斤
#订单是14斤，库存4袋小包装，1袋大包装，所以库存缺少1斤

 输入：(2, 1, 7) ——> 输出：2*1 + 5*1
#订单是7斤，库存2袋小包装，1袋大包装，所以发货1袋大包装+1袋小包装

 输入：(3, 1, 6) ——> 输出​：3*2
#订单是7斤，库存2袋小包装，1袋大包装，所以发货3袋小包装

输入：( 2, 0, 6) ——> 输出：2*2，缺2斤
#订单是6斤，库存2袋小包装，大包装无，所以发货2袋小包装，缺少2斤

 输入：( 8, 0, 7) ——> 输出：2*3，缺1斤
#订单是7斤，库存8袋小包装，大包装无，所以发货1袋大包装+1袋小包装

输入：(8, 15, 3)——> 输出：1*2，缺1斤
#订单是3斤，库存8袋小包装，15袋大包装，所以发货1袋小包装，缺1斤
'''

def order_Capcity(s,l,w):
    larges = min(w//5,l)
    w -= 5 * larges
    if w&1 and larges: w+=5
    smalls = min(s,w//2)

    if w-2*smalls:
        buffer = w-2*smalls-5*larges
        return f"{smalls}小袋和{larges}大袋，缺{buffer}斤"
    return f"{smalls}小袋和{larges-1}大袋"

s,l,w = 4,1,13
s,l,w = 4, 1, 14
s,l,w = 2, 1, 7
s,l,w = 3, 1, 6
s,l,w = 2, 0, 6
s,l,w = 8, 0, 7
s,l,w = 8, 15, 3

orders = [[4,1,13],[4,1,14],[2,1,7],
          [3,1,6],[3,1,6],[2,0,6],
          [8,0,7],[8,15,3]]

for p in orders:
    s,l,w = p
    print(f"订单{w}斤，需要",order_Capcity(s,l,w))