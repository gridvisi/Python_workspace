'''
一个 Python 集合是一个定义明确的不同对象的集合，称为元素或成员。
集合是无序的。集合的元素是唯一的--如果你试图第二次将一个元素添加到一个集合中，它不会有任何影响。
集合本身可以被修改，但是包含在集合中的元素必须是不可变的（实际上是可散列的，但是对于到目前为止你所熟悉的类型，不可变和可散列实际上是一回事）。

'''
print(set('abc'))

frozenset()

x1 = frozenset(['foo'])
x2 = frozenset(['bar'])
x3 = frozenset(['baz'])
x = {x1, x2, x3}
print(x)
#下面哪一个定义了集合{'a', 'b', 'c'}。
s = set(['a', 'b', 'c'] )

#不正确
s = {'a', 'b', 'c'}
#正确的

#s = set('a', 'b', 'c')
#TypeError: set expected at most 1 argument, got 3

s = set('abc')

#不正确
s = {('a', 'b', 'c')}

#正确答案
s = {'a', 'b', 'c'}
#s
{'a','c','b'}

#定义一个集合的最简单方法是在大括号中指定集合的元素。

s = set(['a', 'b', 'c'] )
s
{'a', 'c', 'b'}

s = set('abc')
{'a', 'c', 'b'}


'''
你也可以用内置的set()函数定义一个集合。参数应该是一个产生集合元素的可迭代的东西。
记住，集合是无序的。s显示为{'a', 'c', 'b'}而不是定义中指定的顺序这一事实并没有什么意义。不要忘了，字符串是可以迭代的，并且可以得到组件的字符）。
不正确的答案
>>>
'''
#s = set('a', 'b', 'c')
#回溯（最近一次调用）。  文件"<stdin>"，第1行，在<module>中
#TypeError: set预计最多有1个参数，得到3个参数
#当使用set()函数时，你不能单独指定集合元素。
# set()的参数必须是一个单一的可迭代的元素。

s = {('a', 'b', 'c')}
s
#{('a', 'b', 'c')}
'''
反之，当使用大括号时，你必须单独指定元素。这个例子实际上定义了一个集合。
它包含一个元素--元组('a', 'b', 'c')。
回顾一下。定义一个集合

什么 Python 表达式可以测试字符串 'foo' 是否是集合 s 的成员？
不正确
NameError: name 'foo' 没有被定义
这就是我们期望看到的。in操作符测试集合的成员。
>>>
'''
#'foo'在{'foo', 'bar', 'baz'}中真
#'qux' 在 set(['foo', 'bar', 'baz'])假的

'''
回顾一下。集合大小和成员得到了关于这个问题的反馈
你有一个定义如下的集合s
'''
s = {100, 200, 300}

#以下哪条语句不能正确产生s和集合{300, 400, 500}的并集
s.union(set([300, 400, 500]))

s | {300, 400, 500}

s.union({300, 400, 500})

s.union([300, 400, 500])

# s | [300, 400, 500]
#TypeError: unsupported operand type(s) for |: 'set' and 'list'

s | set([300, 400, 500])

#正确答案

s.union({300, 400, 500})
#{400, 100, 500, 200, 300}

s.union(set([300, 400, 500]))
#{400, 100, 500, 200, 300}

s.union([300, 400, 500])
#{100, 200, 300, 400, 500}

'''

指定给.union()方法的参数可以是一个集合，也可以是一个可迭代的。因此，上述所有
的工作。
(是的，有点奇怪的是，所产生的集合并不是在所有情况下都显示一样的。记住，集合是
无序的：这些都是同一个集合

'''
s | {300, 400, 500}
#{400, 100, 500, 200, 300}

s | set([300, 400, 500])
#{400, 100, 500, 200, 300}

#为|操作符指定的操作数必须是集合。以上两种情况都可以接受。
#不正确的答案

#s | [300, 400, 500]
#TypeError: unsupported operand type(s) for |: 'set' and 'list'
'''
回溯（最近一次调用）  文件"<stdin>"，第1行，在<module>中
类型错误：对于|来说，不支持的操作数类型（）。
'set'和'list'。
这个答案是行不通的，因为可迭代的东西不能成为 | 操作符的目标。
回顾一下。操作符与方法

这个语句的结果是什么。
'''
{'b', 'a', 'r'} & set('qux')
set()
'''
纠正
{'q', 'r', 'x', 'u', 'b', 'a'}
操作符&表示集合相交。问题中的两个集合，{'b', 'a', 'r'}和{'q', 'u', 'x'}，没有任何共同的字符，所以交集是空集。
如果你选择{}作为答案，你可能忘记了{}表示的是一个空字典，而不是一个空集。
回顾一下。可用的运算符和方法

这个语句的结果是什么。
'''
#{1, 2, 3, 4, 5} - {3, 4} ^ {5, 6, 7}
'''

{1, 2}
不正确
设置()
{3, 4, 5, 6, 7}
{1, 2, 6, 7}
不正确
运算符"-"表示集合差异，"^"表示对称性差异。
集合差分有更高的优先权，所以首先执行!!!

>>> {1, 2, 3, 4, 5} - {3, 4}
{1, 2, 5}

然后计算该结果与{5, 6, 7}之间的对称差。
>>>
>>> {1, 2, 5} ^ {5, 6, 7}
{1, 2, 6, 7}

'''
#审查。可用的运算符和方法考虑以下涉及两个集合x和y的表达式。
#(x & y <= x) and (x & y <= y)

#这个表达式对任何集合x和y来说都是真--真还是假？
'''

x & y是x和y的交集。根据定义，它只包含x和y中的元素。
因此，x & y是x和y的一个子集，给定的表达式总是真。
回顾一下。可用的运算符和方法 得到了关于这个问题的反馈

突出显示的表达式的结果是什么。
'''

x = {1, 2, 3}
y = {1, 2}
#y.ispropersubset(x)

'''
Python提供了.issubset()
方法和 <= 操作符来测试一个集合是否是另一个集合的子集。
但是要测试正确的子集， < 操作符是唯一的选择。没有.ispropersubset()
方法。回顾一下。可用的操作符和方法

假设一个集合s被定义如下。
'''
s = {'foo', 'bar', 'baz', 'qux'}

#以下哪种方法可以从s中移除元素 'bar'。
s.pop()
s -= {'bar'} #正确
s.difference_update({'bar'}) #正确

#del s['bar']  # Not

s &= {'foo', 'baz', 'qux'} #

s.discard('bar') #good

s = {'foo', 'bar', 'baz', 'qux'}
s -= {'bar'}
#{'bar', 'foo', 'qux'}

s = {'foo', 'bar', 'baz', 'qux'}
s.difference_update({'bar'})
#s
#{'bar', 'foo', 'qux'}
'''
-= 增强的赋值运算符和.difference_update()
方法都通过删除在指定集合中发现的元素来更新s - -本例中的'bar'。
'''

s = {'foo', 'bar', 'baz', 'qux'}
s.discard('bar')
#{'baz', 'foo', 'qux'}

'''

这是直截了当的：.discard()
方法只是从s中删除指定的对象。回顾一下，如果集合不包含要删除的对象，.discard()
悄悄地不做任何事情。
.remove()
方法也可以从一个集合中删除一个对象，但是如果它不是该集合的成员，则会引发一个异常。
'''


s = {'foo', 'bar', 'baz', 'qux'}
s &= {'foo', 'baz', 'qux'}
#{'baz', 'foo', 'qux'}
'''

&= 增强的赋值运算符更新了s，只保留了在s和指定集合中发现的元素。
因为'bar'不在指定的集合中，所以它被有效地从s中删除。
'''

#不正确的答案:
s = {'foo', 'bar', 'baz', 'qux'}
s.pop()
'baz'

#{'bar', 'foo', 'qux'}

'''
这可能会从s中删除'bar'，但它同样可能会删除其他东西。s.pop()
从s中删除（并返回）一个随机的、任意选择的项目。
'''
s = {'foo', 'bar', 'baz', 'qux'}
del s['bar']
'''
回溯（最近一次调用）。
文件
"<stdin>"，第1行，在 < module > 中
TypeError: 'set'
对象不支持删除项目

这实在是太傻了。你不能用这样的表达式来引用一个单独的集合元素，
而且你也不能用del语句来删除一个集合元素。
令人高兴的是，还有其他几种方法可以做到这一点）。
回顾一下。修改一个集合

'''
#关于冻结集合，以下哪些是真的。
'''
如果f是一个冻结集合，语句f.add('foo')
将引发一个异常。
正确
如果f是一个冻结的集合，语句f |= {'foo'}
将引发一个异常。
不正确
你可以用这种语法定义一个冻结集。
f = f
{'a', 'b', 'c'}

冻结集可以是一个集合的成员，并且可以作为一个字典的键。
正确答案
正确答案
f.add()
会引发一个异常。冻结的集合是不可变的，所以对标准集合的修改方法对冻结的集合是不可用的。
冻结集可以用在需要一个不可变的对象的情况下，比如一个集合的成员或一个字典的键。
不正确的答案
f |= {'foo'}
不会引发异常。在这个例子中， |= 增强的赋值运算符并没有直接修改f。
相反，它创建了一个新的冻结集合，等于原来的f，并加上了'foo'
没有内置的Python语法来定义一个冻结集，就像对标准集那样。唯一的方法是使用
'''
frozenset()

x1 = frozenset(['foo'])
x2 = frozenset(['bar'])
x3 = frozenset(['baz'])
x = {x1, x2, x3}
print(x)