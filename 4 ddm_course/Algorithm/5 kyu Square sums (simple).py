'''
https://www.codewars.com/kata/5a6b24d4e626c59d5b000066/train/python

这是较难的平方和的简单版本。

平方和
编写函数 square_sums_row ( 或 squareSumsRow 或 SquareSumsRow )，
给定整数 N (范围为 2...43)，返回整数 1...N 的数组，其排列方式使每两个
连续数字之和为平方。

当且仅当以下两个标准得到满足时，解决方案才是有效的。

1...N范围内的每个数字都被使用一次，而且只有一次。
每两个连续的数字之和是一个完全的平方。
例子
对于N=15的解决方案可以是这样的。

[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]

验证
所有的数字都被使用一次，而且只有一次。当以升序排序时，数组看起来像这样。
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]

每两个连续的数字之和是一个完全的平方。
   16 16 16 16 16 16 16
   /+\ /+\ /+\ /+\ /+\ /+\ /+\
[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]
      \+/ \+/ \+/ \+/ \+/ \+/ \+/
       9 25 9 25 9 25 9

 9 = 3*3
16 = 4*4
25 = 5*5
如果没有解决方案，返回false（Scala中为None，Haskell中为Nothing）。
例如，如果N=5，那么数字1,2,3,4,5不能被放入平方和行：1+3=4，4+5=9，
但是2没有配对，不能连接[1,3]和[4,5]。

玩得开心点!
这个卡塔的较难版本在这里。

算法数学数字

描述：
Write function square_sums_row (or squareSumsRow/SquareSumsRow depending on language rules) that, given integer number N (in range 2…43), returns array of integers 1…N arranged in a way, so sum of each 2 consecutive numbers is a square.
Solution is valid if and only if following two criterias are met:
Each number in range 1…N is used once and only once.
Sum of each 2 consecutive numbers is a perfect square.
Example
For N=15 solution could look like this:
[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]

分析：
如果系统学习过深度优先搜索(DFS)，应该很自然地想到用DFS求解该问题。此问题不需要遍历所有路径，只需搜索到一条满足条件的路径即可。
具体来说，以N=15为例，最终结果应该是包含15个数的序列。第一个数有可能是[1, 15]中的任何一个。首先从1开始遍历。此时第二个数必须满足以下条件：
1. 属于[1, 15]中除去前面步骤已占用的数字；
2. 和结果序列前一个数字的和为某整数平方和。
依条件，第二个数不能是1，因为1已被结果序列前面的位置占用；也不能是2，因为2和序列前一个数字1的和是3，开方不是整数。3是备选项，因为3没有被结果序列前面位置所占用，同时和序列前一个数字1的和是4，是2的平方。此时结果序列暂定为[1, 3]。按照以上步骤反复推进，直到[1, 3, 6, 10, 15]。此时在位置6上，剩余可选的数字分别是：2, 4, 5, 7, 8, 9, 11, 12, 13, 14。这些数字与当前结果序列最后一个数字15相加，都无法成为整数的平方。此时说明：结果序列第5个位置不能是15。因此我们从位置6回溯到位置5，此时在位置5上，之前已经遍历过了1到14，都不满足要求，15又因为后续无以为继而放弃，已没有合适的数放置，因此我们继续回溯，回溯到位置4。位置4之前是10，此时说明位置4不能是10，剩余可选数字是11, 12, 13, 14, 15。很遗憾，这5个数字和此时结果序列前一个数字6的和无法构成整数的平方，因此必须继续回溯。回溯到位置3，此时从7开始寻找下一个满足条件的数字，我们发现13是满足条件的数字。以13作为第三个位置上的数字，此时结果序列暂定为[1, 3, 13]，继续向后递归遍历，直到所有15个位置都被放置数字。
回溯深度优先查找算法的代码基本框架是：
————————————————
版权声明：本文为CSDN博主「thinshootout」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/thinshootout/article/details/103086934
'''


