'''
https://www.codewars.com/kata/5a667236145c462103000091/train/python

方形和
写一个函数，给定一个整数N，返回以某种方式排列的整数1...N的数组，这样每两个连续的数字
之和就是一个平方。

当且仅当以下两个标准得到满足时，解决方案才有效。

1...N范围内的每个数字都被使用一次，而且只使用一次。
每两个连续的数字之和是一个完全的平方。
例子
对于N=15的解决方案可以是这样的。

[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]

验证
所有的数字都被使用一次，而且只有一次。当以升序排序时，数组看起来像这样。
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]

每两个连续的数字之和是一个完全的平方。
   16 16 16 16 16 16 16
   /+\ /+\ /+\ /+\ /+\ /+\ /+\
[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]
      \+/ \+/ \+/ \+/ \+/ \+/ \+/
       9 25 9 25 9 25 9

9 = 3*3
16 = 4*4
25 = 5*5
如果没有解决方案，则返回False（C++中的空向量；Java中的空）。
例如，如果N=5，那么数字1,2,3,4,5不能被放入平方和行中：1+3=4，4+5=9，但是2没有配对，不能连接[1,3]和[4,5] 。


测试约束。
1 <= N <= 1000
所有可能的N值都被测试
蛮力解法只能达到N=50。
代码大小被限制在20K以内，外部模块被禁用：内联所有预先计算的结果不是一个选项。

玩得开心点!
这个卡塔的简单版本在这里。

美丽的卡塔，是迄今为止我收获最大的卡塔，谢谢你

我很快就想出了高层次的解决方案，并编写了一个粗略的实现方案，但我发现，对于大的n来说，它需要花费大量的时间。

一个小小的评论。我认为Python解决方案应该被要求在没有解决方案时返回None，而不是False。

这很有启发性。我的第一个算法在我的老苹果机上对(1, 1000)的所有数字花了10分钟。经过简单的修正，它降到了80秒。然后经过一天的思考--降到了24秒。然后我给算法增加了两项调整，我确信这将大大改善它。特别是检查当前顶点是否已经在当前分支中被调查过，以及达到的最大深度是多少等等。但所有这些只是将4秒缩短到20秒！:) 但这一切只是将4秒缩短到20秒！:) 还是足以通过的。
我现在对Python肯定有了更多的了解。
'''