# https://blog.csdn.net/lnotime/article/details/82319973
'''
算法
马青公式：马青公式由英国天文学教授约翰·马青(John Machin ，1686 –1751)于1706年发现。
马青公式每计算一项可以得到1.4位的十进制精度。因为它的计算过程中被乘数和被除数都不大于长整数，
所以可以很容易地在计算机上编程实现。
'''
pi = 3.1415159265
pi_str = str(pi)
print(pi_str[3])

import math
x = 3.14
print(int(x))
print(float(1/3))

float(math.pi)
print("%.100f"%math.pi)

n = 10000+4
p = 2*10**n
a = p//3; p += a
i = 2
while a > 0:
    a = a*i//(i*2+1); i += 1
    p += a
p //= 10000
print("PI=",p)

'''
注意1：由于程序中浮点数的有效位数有限（小数点后很长的话会被省略，很大的数如果是小数也会用科学技术法），
会损失很大精度，所以用整数来计算π。

比如想计算小数点后 7 位，就计算 π * 10^7 是多少，返回 31415926。
比如想计算小数点后 3 位，程序就会给你返回整数 3141，是扩大了 10^3 的结果。

注意2:  想用整数计算 π，那除法的时候就要使用取模运算来保证结果也是整数，以达到保证精度的目的。

注意3: 我用取模操作代替了除法，但是取模对于除法来说本身就是有精度损失的，为了弥补这部分精度，我采取的方案是，
先把想精确的位数增加 k，最后把结果减少 k 位。

注意4: 从这句话以后的 n，不再指代上面求 π 的数学公式中的 n，而代表输入的想要精确 π 的位数。

可以预见，注意3中提出的这个方案是有漏洞的，因为 k 是被固定在程序中的，随着用户输入 n 的增大，
越来越大量的取模运算损失的精度，必定是固定不变的 k 值所不能弥补的。所以对每一个固定的 k，一定会有一个 n 值，
使得本程序所计算的结果是错误的。

对此，我还有一个方案，k 值不固定，由 n 计算得出，n 越大就取越大的 k。但我不想随便定一个 k 与 n 的关系，
当然通过代码可以试出一个不错的，但程序计算总有尽头，没有理论支持就无法证明这个关系是真正合理的。
————————————————

'''

#原文链接：https: // blog.csdn.net / csdncaoguo940713 / java / article / details / 90207769
import math
def get_pi_value(x):
    if (x > 0):
        num = math.pow(10, x)
        val = int(math.pi * num)
        print(val)
    else:
        print('输入有误')

for i in range(10):
    get_pi_value(i * 10)

n = 10000